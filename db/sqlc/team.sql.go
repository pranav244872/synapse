// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.29.0
// source: team.sql

package db

import (
	"context"

	"github.com/jackc/pgx/v5/pgtype"
)

const countTeams = `-- name: CountTeams :one

SELECT count(*) FROM teams
`

// SQLC-formatted queries for the "teams" table.
// These follow the conventions for use with the sqlc tool.
// Returns the total number of teams.
func (q *Queries) CountTeams(ctx context.Context) (int64, error) {
	row := q.db.QueryRow(ctx, countTeams)
	var count int64
	err := row.Scan(&count)
	return count, err
}

const createTeam = `-- name: CreateTeam :one
INSERT INTO teams (
  team_name,
  manager_id
) VALUES (
  $1, $2
) RETURNING id, team_name, manager_id
`

type CreateTeamParams struct {
	TeamName  string      `json:"team_name"`
	ManagerID pgtype.Int8 `json:"manager_id"`
}

// Inserts a new team into the teams table.
// Added manager_id to allow assigning a manager upon creation.
// The manager_id can be NULL if a team is created without an immediate manager.
func (q *Queries) CreateTeam(ctx context.Context, arg CreateTeamParams) (Team, error) {
	row := q.db.QueryRow(ctx, createTeam, arg.TeamName, arg.ManagerID)
	var i Team
	err := row.Scan(&i.ID, &i.TeamName, &i.ManagerID)
	return i, err
}

const deleteTeam = `-- name: DeleteTeam :exec
DELETE FROM teams
WHERE id = $1
`

// Deletes a team from the database by its ID.
func (q *Queries) DeleteTeam(ctx context.Context, id int64) error {
	_, err := q.db.Exec(ctx, deleteTeam, id)
	return err
}

const getTeam = `-- name: GetTeam :one
SELECT id, team_name, manager_id FROM teams
WHERE id = $1 LIMIT 1
`

// Retrieves a single team by its unique ID.
func (q *Queries) GetTeam(ctx context.Context, id int64) (Team, error) {
	row := q.db.QueryRow(ctx, getTeam, id)
	var i Team
	err := row.Scan(&i.ID, &i.TeamName, &i.ManagerID)
	return i, err
}

const getTeamByManagerID = `-- name: GetTeamByManagerID :one
SELECT id, team_name, manager_id FROM teams
WHERE manager_id = $1 LIMIT 1
`

// Get a team by the manager's user ID.
// Since manager_id is unique, this will return at most one team.
func (q *Queries) GetTeamByManagerID(ctx context.Context, managerID pgtype.Int8) (Team, error) {
	row := q.db.QueryRow(ctx, getTeamByManagerID, managerID)
	var i Team
	err := row.Scan(&i.ID, &i.TeamName, &i.ManagerID)
	return i, err
}

const listTeams = `-- name: ListTeams :many
SELECT id, team_name, manager_id FROM teams
ORDER BY id
LIMIT $1
OFFSET $2
`

type ListTeamsParams struct {
	Limit  int32 `json:"limit"`
	Offset int32 `json:"offset"`
}

// Retrieves a paginated list of all teams, ordered by ID.
func (q *Queries) ListTeams(ctx context.Context, arg ListTeamsParams) ([]Team, error) {
	rows, err := q.db.Query(ctx, listTeams, arg.Limit, arg.Offset)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []Team
	for rows.Next() {
		var i Team
		if err := rows.Scan(&i.ID, &i.TeamName, &i.ManagerID); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listTeamsWithManagers = `-- name: ListTeamsWithManagers :many
SELECT t.id, team_name, manager_id, u.id, name, email, team_id, availability, password_hash, role
FROM teams t
LEFT JOIN users u ON t.manager_id = u.id
ORDER BY t.id
LIMIT $1
OFFSET $2
`

type ListTeamsWithManagersParams struct {
	Limit  int32 `json:"limit"`
	Offset int32 `json:"offset"`
}

type ListTeamsWithManagersRow struct {
	ID           int64                  `json:"id"`
	TeamName     string                 `json:"team_name"`
	ManagerID    pgtype.Int8            `json:"manager_id"`
	ID_2         pgtype.Int8            `json:"id_2"`
	Name         pgtype.Text            `json:"name"`
	Email        pgtype.Text            `json:"email"`
	TeamID       pgtype.Int8            `json:"team_id"`
	Availability NullAvailabilityStatus `json:"availability"`
	PasswordHash pgtype.Text            `json:"password_hash"`
	Role         NullUserRole           `json:"role"`
}

// List all teams and include their manager's details.
// This uses a LEFT JOIN to ensure teams without a manager are still included.
// This is useful for UI displays to avoid separate lookups for manager names.
func (q *Queries) ListTeamsWithManagers(ctx context.Context, arg ListTeamsWithManagersParams) ([]ListTeamsWithManagersRow, error) {
	rows, err := q.db.Query(ctx, listTeamsWithManagers, arg.Limit, arg.Offset)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []ListTeamsWithManagersRow
	for rows.Next() {
		var i ListTeamsWithManagersRow
		if err := rows.Scan(
			&i.ID,
			&i.TeamName,
			&i.ManagerID,
			&i.ID_2,
			&i.Name,
			&i.Email,
			&i.TeamID,
			&i.Availability,
			&i.PasswordHash,
			&i.Role,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listUnmanagedTeams = `-- name: ListUnmanagedTeams :many
SELECT id, team_name, manager_id FROM teams
WHERE manager_id IS NULL
ORDER BY team_name
`

// Retrieves all teams that do not have a manager_id assigned.
// Useful for populating dropdowns for manager assignment.
func (q *Queries) ListUnmanagedTeams(ctx context.Context) ([]Team, error) {
	rows, err := q.db.Query(ctx, listUnmanagedTeams)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []Team
	for rows.Next() {
		var i Team
		if err := rows.Scan(&i.ID, &i.TeamName, &i.ManagerID); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const setTeamManager = `-- name: SetTeamManager :one
UPDATE teams
SET manager_id = $2
WHERE id = $1
RETURNING id, team_name, manager_id
`

type SetTeamManagerParams struct {
	ID        int64       `json:"id"`
	ManagerID pgtype.Int8 `json:"manager_id"`
}

// Sets the manager for a specific team.
func (q *Queries) SetTeamManager(ctx context.Context, arg SetTeamManagerParams) (Team, error) {
	row := q.db.QueryRow(ctx, setTeamManager, arg.ID, arg.ManagerID)
	var i Team
	err := row.Scan(&i.ID, &i.TeamName, &i.ManagerID)
	return i, err
}

const updateTeam = `-- name: UpdateTeam :one
UPDATE teams
SET 
  team_name = COALESCE($2, team_name),
  manager_id = $3
WHERE id = $1
RETURNING id, team_name, manager_id
`

type UpdateTeamParams struct {
	ID        int64       `json:"id"`
	TeamName  pgtype.Text `json:"team_name"`
	ManagerID pgtype.Int8 `json:"manager_id"`
}

// Updates the name and/or the manager of a specific team.
// Uses COALESCE and sqlc.narg to allow optional updates.
// You can update the name, the manager_id, or both in a single call.
func (q *Queries) UpdateTeam(ctx context.Context, arg UpdateTeamParams) (Team, error) {
	row := q.db.QueryRow(ctx, updateTeam, arg.ID, arg.TeamName, arg.ManagerID)
	var i Team
	err := row.Scan(&i.ID, &i.TeamName, &i.ManagerID)
	return i, err
}
